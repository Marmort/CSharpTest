using System;
using System.IO;
using System.Text;
using System.Reflection;

namespace ProtocolBuffers
{
    public static class CodeGenerator
    {
        /// <summary>
        /// Generate code for reading and writing protocol buffer messages
        /// </summary>
        public static void Save(Proto p, string nameSpace, string csPath)
        {
            using (TextWriter codeWriter = new StreamWriter(csPath, false, Encoding.UTF8))
            {
                codeWriter.WriteLine(@"//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;

namespace " + nameSpace + "\n{\n");

                foreach (var m in p.Messages)
                {
                    SaveMessage(p, m.Value, codeWriter);
                }

                codeWriter.WriteLine("}");

                //Copy ProtocolParser files contents
                string sourcePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
                ReadCode(codeWriter, Path.Combine(sourcePath, "ProtocolParser.cs"));
            }
        }

        /// <summary>
        /// Read c# code from sourcePath and write it on code without the initial using statements.
        /// </summary>
        private static void ReadCode(TextWriter code, string sourcePath)
        {
            code.WriteLine("#region " + Path.GetFileName(sourcePath));
            foreach (string line in File.ReadAllLines(sourcePath, Encoding.UTF8))
            {
                if (line.StartsWith("using"))
                    continue;

                code.WriteLine(line);
            }
            code.WriteLine("#endregion");
        }

        private static void SaveMessage(Proto p, Message m, TextWriter codeWriter)
        {
            m.Name = ProtoPrepare.GetCamelCase(m.Name);
            //Prepare fields
            foreach (Field f in m.Fields)
            {
                ProtoPrepare.PrepareProtoType(m, f);
            }
            foreach (var e in m.Enums)
            {
                e.Value.Name = ProtoPrepare.GetCamelCase(e.Value.Name);
            }

            codeWriter.WriteLine(Indent(1, GenerateInterface(m)));
            codeWriter.WriteLine(Indent(1, GenerateClass(m)));

        }

        static string GenerateInterface(Message m)
        {
            string prop = "";
            foreach (Field f in m.Fields)
            {
                if (f.Deprecated)
                    prop += "[Obsolete]\n";
                if (f.ProtoType == ProtoTypes.Message)
                    prop += "I" + f.CSType + " " + f.Name + " { get; set; }\n";
                else
                    prop += f.CSType + " " + f.Name + " { get; set; }\n";
            }
            string code = "";
            code += "public interface I" + m.Name + "\n";
            code += "{\n";
            code += Indent(prop);
            code += "}\n";
            return code;
        }

        static string GenerateClass(Message m)
        {
            //Enums
            string enums = "";
            foreach (var mepair in m.Enums)
            {
                enums += "public enum " + mepair.Value.Name + "\n";
                enums += "{\n";
                foreach (var epair in mepair.Value.Enums)
                    enums += "	" + epair.Key + " = " + epair.Value + ",\n";
                enums += "}\n";
            }

            //Properties
            string properties = "";
            foreach (Field f in m.Fields)
            {
                if (f.ProtoType == ProtoTypes.Message)
                    properties += "public I" + f.CSType + " " + f.Name + " { get; set; }\n";
                else
                    properties += "public " + f.CSType + " " + f.Name + " { get; set; }\n";
            }

            //Constructor with default values
            string constructor = "public " + m.Name + "()\n";
            constructor += "{\n";
            foreach (Field f in m.Fields)
            {
                if (f.Rule == Rules.Repeated)
                    constructor += "	this." + f.Name + " = new " + f.CSType + "();\n";
                if (f.Default != null)
                    constructor += "	this." + f.Name + " = " + ProtoPrepare.GetCSDefaultValue(f) + ";\n";
            }
            constructor += "}\n";

            //Default class
            string code = "";
            code += "public class " + m.Name + " : I" + m.Name + "\n";
            code += "{\n";
            code += Indent(enums);
            code += "\n";
            code += Indent(properties);
            code += "\n";
            code += Indent(constructor);
            code += "\n";
            code += Indent(GenerateReader(m));
            code += "\n";
            code += Indent(GenerateWriter(m));
            code += "}\n";
            return code;
        }

        #region Protocol Reader

        static string GenerateReader(Message m)
        {
            string code = "";
            code += "public static " + m.Name + " Read(Stream stream)\n";
            code += "{\n";
            code += "	" + m.Name + " instance = new " + m.Name + "();\n";
            code += "	Read(stream, instance);\n";
            code += "	return instance;\n";
            code += "}\n";
            code += "\n";
            code += "public static " + m.Name + " Read(byte[] buffer)\n";
            code += "{\n";
            code += "	using(MemoryStream ms = new MemoryStream(buffer))\n";
            code += "		return Read(ms);\n";
            code += "}\n";
            code += "\n";
            code += "public static I" + m.Name + " Read(byte[] buffer, I" + m.Name + " instance)\n";
            code += "{\n";
            code += "	using(MemoryStream ms = new MemoryStream(buffer))\n";
            code += "		return Read(ms, instance);\n";
            code += "}\n";
            code += "\n";
            code += "public static I" + m.Name + " Read (Stream stream, I" + m.Name + " instance)\n";
            code += "{\n";
            foreach (Field f in m.Fields)
            {
                if (f.WireType == Wire.Fixed32 || f.WireType == Wire.Fixed64)
                {
                    code += "	BinaryReader br = new BinaryReader (stream);";
                    break;
                }
            }
            code += "	while (true)\n";
            code += "	{\n";
            code += "		Key key = null;\n";
            code += "		try {\n";
            code += "			key = ProtocolParser.ReadKey (stream);\n";
            code += "		} catch (InvalidDataException) {\n";
            code += "			break;\n";
            code += "		}\n";
            code += "\n";
            code += "		switch (key.Field) {\n";
            foreach (Field f in m.Fields)
            {
                code += "		case " + f.ID + ":\n";
                code += Indent(3, GenerateFieldReader(f)) + "\n";
                code += "			break;\n";
            }
            code += "		default:\n";
            code += "			ProtocolParser.SkipKey(stream, key);\n";
            code += "			break;\n";
            code += "		}\n";
            code += "	}\n";
            code += "	return instance;\n";
            code += "}\n";
            return code;
        }

        static string GenerateFieldReader(Field f)
        {
            string code = "";
            if (f.Rule == Rules.Repeated)
            {
                if (f.Packed == true)
                {
                    code += "using(MemoryStream ms" + f.ID + " = new MemoryStream(ProtocolParser.ReadBytes(stream)))\n";
                    code += "{\n";
                    code += "	while(true)\n";
                    code += "	{\n";
                    code += "		if(ms" + f.ID + ".Position == ms" + f.ID + ".Length)\n";
                    code += "			break;\n";
                    code += "		instance." + f.Name + ".Add(" + GenerateFieldTypeReader(f, "ms" + f.ID, "br", null) + ");\n";
                    code += "	}\n";
                    code += "}\n";
                }
                else
                {
                    code += "instance." + f.Name + ".Add(" + GenerateFieldTypeReader(f, "stream", "br", null) + ");";
                }
            }
            else
            {
                if (f.ProtoType == ProtoTypes.Message)
                {
                    code += "if(instance." + f.Name + " == null)\n";
                    code += "	instance." + f.Name + " = new " + f.CSType + "();\n";
                }
                code += "instance." + f.Name + " = " + GenerateFieldTypeReader(f, "stream", "br", "instance." + f.Name) + ";";
            }
            return code;
        }

        static string GenerateFieldTypeReader(Field f, string stream, string binaryReader, string instance)
        {
            switch (f.ProtoType)
            {
                case ProtoTypes.Double:
                    return "br.ReadDouble ()";
                case ProtoTypes.Float:
                    return "br.ReadSingle ()";
                case ProtoTypes.Fixed32:
                    return "br.ReadUInt32 ()";
                case ProtoTypes.Fixed64:
                    return "br.ReadUInt64 ()";
                case ProtoTypes.Sfixed32:
                    return "br.ReadInt32 ()";
                case ProtoTypes.Sfixed64:
                    return "br.ReadInt64 ()";
                case ProtoTypes.Int32:
                    return "(int)ProtocolParser.ReadUInt32(" + stream + ")";
                case ProtoTypes.Int64:
                    return "(long)ProtocolParser.ReadUInt64(" + stream + ")";
                case ProtoTypes.Uint32:
                    return "ProtocolParser.ReadUInt32(" + stream + ")";
                case ProtoTypes.Uint64:
                    return "ProtocolParser.ReadUInt64(" + stream + ");";
                case ProtoTypes.Sint32:
                    return "ProtocolParser.ReadSInt32(" + stream + ");";
                case ProtoTypes.Sint64:
                    return "ProtocolParser.ReadSInt64(" + stream + ");";
                case ProtoTypes.Bool:
                    return "ProtocolParser.ReadBool(" + stream + ")";
                case ProtoTypes.String:
                    return "ProtocolParser.ReadString(" + stream + ")";
                case ProtoTypes.Bytes:
                    return "ProtocolParser.ReadBytes(" + stream + ")";
                case ProtoTypes.Enum:
                    return "(" + f.CSItemType + ")ProtocolParser.ReadUInt32(" + stream + ")";
                case ProtoTypes.Message:
                    if (f.Rule == Rules.Repeated)
                        return f.CSItemType + ".Read(ProtocolParser.ReadBytes(" + stream + "))";
                    else
                        return f.CSItemType + ".Read(ProtocolParser.ReadBytes(" + stream + "), " + instance + ")";
                default:
                    throw new NotImplementedException();
            }
        }

        #endregion

        #region Protocol Writer

        /// <summary>
        /// Generates code for writing a class/message
        /// </summary>
        static string GenerateWriter(Message m)
        {
            string code = "	public static void Write(Stream stream, I" + m.Name + " instance)\n";
            code += "{\n";
            if (GenerateBinaryWriter(m))
                code += "	BinaryWriter bw = new BinaryWriter(stream);\n";

            foreach (Field f in m.Fields)
            {
                code += Indent(GenerateFieldWriter(m, f));
            }
            code += "}\n";
            return code;
        }

        /// <summary>
        /// Adds BinaryWriter only if it will be used
        /// </summary>
        static bool GenerateBinaryWriter(Message m)
        {
            foreach (Field f in m.Fields)
            {
                if (f.WireType == Wire.Fixed32 || f.WireType == Wire.Fixed64)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Generates code for writing one field
        /// </summary>
        static string GenerateFieldWriter(Message m, Field f)
        {
            string code = "";
            if (f.Rule == Rules.Repeated)
            {
                if (f.Packed == true)
                {
                    string binaryWriter = "";
                    switch (f.ProtoType)
                    {
                        case ProtoTypes.Double:
                        case ProtoTypes.Float:
                        case ProtoTypes.Fixed32:
                        case ProtoTypes.Fixed64:
                        case ProtoTypes.Sfixed32:
                        case ProtoTypes.Sfixed64:
                            binaryWriter = "\nBinaryWriter bw" + f.ID + " = new BinaryWriter(ms" + f.ID + ");";
                            break;
                    }

                    code += "ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
                    code += "using(MemoryStream ms" + f.ID + " = new MemoryStream())\n";
                    code += "{	" + binaryWriter + "\n";
                    code += "	foreach (" + f.CSItemType + " i" + f.ID + " in instance." + f.Name + ")\n";
                    code += "	{\n";
                    code += "" + Indent(2, GenerateFieldTypeWriter(f, "ms" + f.ID, "bw" + f.ID, "i" + f.ID)) + "\n";
                    code += "	}\n";
                    code += "	ProtocolParser.WriteBytes(stream, ms" + f.ID + ".ToArray());\n";
                    code += "}\n";
                    return code;
                }
                else
                {
                    code += "foreach (" + f.CSItemType + " i" + f.ID + " in instance." + f.Name + ")\n";
                    code += "{\n";
                    code += "	ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
                    code += "" + Indent(1, GenerateFieldTypeWriter(f, "stream", "bw", "i" + f.ID)) + "\n";
                    code += "}\n";
                    return code;
                }
            }
            else if (f.Rule == Rules.Optional)
            {
                switch (f.ProtoType)
                {
                    case ProtoTypes.String:
                    case ProtoTypes.Message:
                    case ProtoTypes.Bytes:
                        code += "if(instance." + f.Name + " != null)\n";
                        code += "{\n";
                        code += "	ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
                        code += Indent(GenerateFieldTypeWriter(f, "stream", "bw", "instance." + f.Name));
                        code += "}\n";
                        return code;
                    default:
                        code += "ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
                        code += GenerateFieldTypeWriter(f, "stream", "bw", "instance." + f.Name);
                        return code;
                }
            }
            else if (f.Rule == Rules.Required)
            {
                switch (f.ProtoType)
                {
                    case ProtoTypes.String:
                    case ProtoTypes.Message:
                    case ProtoTypes.Bytes:
                        code += "if(instance." + f.Name + " == null)\n";
                        code += "	throw new ArgumentNullException(\"" + f.Name + "\", \"Required by proto specification.\");\n";
                        break;
                }
                code += "ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
                code += GenerateFieldTypeWriter(f, "stream", "bw", "instance." + f.Name);
                return code;
            }
            throw new NotImplementedException("Unknown rule: " + f.Rule);
        }

        static string GenerateFieldTypeWriter(Field f, string stream, string binaryWriter, string instance)
        {
            switch (f.ProtoType)
            {
                case ProtoTypes.Double:
                case ProtoTypes.Float:
                case ProtoTypes.Fixed32:
                case ProtoTypes.Fixed64:
                case ProtoTypes.Sfixed32:
                case ProtoTypes.Sfixed64:
                    return binaryWriter + ".Write(" + instance + ");";
                case ProtoTypes.Int32:
                    return "ProtocolParser.WriteUInt32(" + stream + ", (uint)" + instance + ");";
                case ProtoTypes.Int64:
                    return "ProtocolParser.WriteUInt64(" + stream + ", (ulong)" + instance + ");";
                case ProtoTypes.Uint32:
                    return "ProtocolParser.WriteUInt32(" + stream + ", " + instance + ");";
                case ProtoTypes.Uint64:
                    return "ProtocolParser.WriteUInt64(" + stream + ", " + instance + ");";
                case ProtoTypes.Sint32:
                    return "ProtocolParser.WriteSInt32(" + stream + ", " + instance + ");";
                case ProtoTypes.Sint64:
                    return "ProtocolParser.WriteSInt64(" + stream + ", " + instance + ");";
                case ProtoTypes.Bool:
                    return "ProtocolParser.WriteBool(" + stream + ", " + instance + ");";
                case ProtoTypes.String:
                    return "ProtocolParser.WriteString(" + stream + ", " + instance + ");";
                case ProtoTypes.Bytes:
                    return "ProtocolParser.WriteBytes(" + stream + ", " + instance + ");";
                case ProtoTypes.Enum:
                    return "ProtocolParser.WriteUInt32(" + stream + ", (uint)" + instance + ");";
                case ProtoTypes.Message:
                    string code = "";
                    code += "using(MemoryStream ms" + f.ID + " = new MemoryStream())\n";
                    code += "{\n";
                    code += "	" + f.CSItemType + ".Write(ms" + f.ID + ", " + instance + ");\n";
                    code += "	ProtocolParser.WriteBytes(" + stream + ", ms" + f.ID + ".ToArray());\n";
                    code += "}\n";
                    return code;
                default:
                    throw new NotImplementedException();
            }
        }

        #endregion

        /// <summary>
        /// Indent all lines in the code string with one tab
        /// </summary>
        private static string Indent(string code)
        {
            return Indent(1, code);
        }

        /// <summary>
        /// Indent all lines in the code string with given number of tabs
        /// </summary>
        private static string Indent(int tabs, string code)
        {
            string sep = "\n";
            for (int n = 0; n < tabs; n++)
                sep += "\t";
            code = sep + string.Join(sep, code.Split('\n'));
            return code.Substring(1).TrimEnd('\t');
        }
    }
}
